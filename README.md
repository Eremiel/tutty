# Tutorial Template

This platform provides an in-browser environment for online tutorials. It is meant as a 
starting point for developing interactive, terminal-based tutorials. 

The platform provides a web-interface that shows guidance on the left-hand side and a terminal
window to follow along and try out things on the right hand-side. 

## Getting started

The platform relies on multiple components that all work together. A fully functional containerized development 
environment can be started with

```bash
docker-compose up
```

After start-up (which can take a few moments), the webpage should be available at 

```
http://localhost:3000
```

The platform creates the following containers:

| Service   | Description                                                                                               |
| --------- | --------------------------------------------------------------------------------------------------------- |
| `web`     | Provides the web front-end. In development mode, this refreshes is the source code changes.               |
| `backend` | Provides a sample backend service for testing.                                                            |
| `redis`   | A [Redis](https://redis.io) instance for maintaining state and coordination between front-end and backend |
| `ldap`    | An [OpenLDAP](https://www.openldap.org/) server for managing users.                                       |

## Repository structure

The repository contains source code for the frontend, the souces for a sample tutorial, as well as a backend template. The top-level folder contains:

| Folder           | Description                                    |
| ---------------- | ---------------------------------------------- |
| `site`           | Sources for the static content of the Tutorial |
| `src/client`     | Sources for the client-side web app            |
| `src/server`     | Sources for the server-side web app            |
| `assets/web`     | Assets for the front-end container             |
| `assets/backend` | Assets for the terminal backend                |
| `deployments`    | Deployment examples                            |

## Architecture

## Tutorial content

The tutorial content is generated by [Hugo](https://gohugo.io), a fast static web-site generator, from the [Markdown](https://daringfireball.net/projects/markdown/) content in the `site` folder. The folder contains everything needed to generate the static assets for the front-end, including:

- `content` - the actual content of the tutorial
- `themes` - the Hugo theme used for rendering the webpage
- `static` - static content used by the tutorial (e.g., images and custom JavaScripts)
- `archtypes` - for generating new content using the `hugo new` command
- `shortcodes` - for custom shortcodes (a Hugo feature) used in the tutorial sources

Most of the editing should happen in the `content` folder.

### Frontend

The frontend is a [Node.js](https://nodejs.org/)-based web application that has two components:

- `backend` implements the webserver with routing facilities and a [Websocket](https://en.wikipedia.org/wiki/WebSocket) to channel terminal data between the client browser and the backend. 
- `client` provides a client-side JavaScript for managing the terminal.

Both are strongly based on [Wetty](https://github.com/krishnasrinivas/wetty), a in-browser terminal similar to [Anyterm](https://anyterm.org/).

### Supporting services

#### User management

The platform is *fully user-aware*, which means that you can provide separated environments for every user. Responsibility to authenticate users is delegated by the frontend to an [OAuth 2.0](https://oauth.net/2/) identity provider. Currently, only Github is available.

If a new user accesses the frontend, (s)he is redirected to the OAuth endpoint to authenticate using his credentials. The users profile (only the username is used) is accessed by the frontend to create a new local user for logging into the backend. Local user information is handled by an [OpenLDAP](https://www.openldap.org/) server. The server is accessed by the frontend to create/verify users and by the backends to ensure the same username/uid/gid combinations are used on all backend instances.

In addition, a [JSON Web Token](https://jwt.io/) (JWT) is created and stored as a cookie in the clients browser to authenticate with the terminal websocket. The JWT is used by the frontend server to pass the username to the backend when a new terminal connection is established. It is also used to efficiently authenticate access to the static resources, preventing excessive access of the OAuth endpoint. The JWT expires periodically. An expired JWT is replaced by a round-trip to the OAuth endpoint, which should be largely transparent to the user (apart from a slight increased response time).

#### Backend access

The backend is accessed through ssh. It is not directly exposed to the client, who is meant to access the backend only through the web-terminal. The frontend effectively acts as a bridge. Communication between client and frontend uses websockets, and communcation between frontend and backend uses ssh. When a client-side in-browser terminal establishes a new websocket connection, the frontend server establishes a new ssh connection to the backend using *hostbased* authentication and the username, determined from the JWT token passed as a cookie. It then forwards data bi-directionally between client and backend.

The platform is designed to work in dynamic environments (i.e., container orchestation). This brings some challenges for *hostbased* ssh authentication, because the backend ssh configuration needs updating if the frontend changes. This is achieved by [hostmgr](https://github.com/kramergroup/hostmgr). *The hostmgr helper has to run on each frontend and each backend* for dynamic ssh configuration to work. Hostmgr uses a [Redis](https://redis.io/) server to maintain and communicate state between frontends and backends. This architecture allows to scale frontend and backends independently.

### Persistence

The development environment does not persist any data. This is not advisible for production. The following volumes/folders should be configured to use persistent storage in production:

| Service   | Folder          | Comment                                                                                                    |
| --------- | --------------- | ---------------------------------------------------------------------------------------------------------- |
| `ldap`    | `/var/lib/ldap` | The LDAP data directory contains user information. Note that the folder depends on the used LDAP instance. |
| `redis`   | `/data`         | The Redis data directory contains state information of the frontend and backend hosts                      |
| `backend` | `/home`         | The home directories of all users. This should be mounted to an NFS server in most use-cases.              |
